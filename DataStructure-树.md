---
title: DataStructure-二叉树
---
## 树的基础知识点

1. 树中的结点层次：从树根开始定义，根节点为第一层，根节点的子女为第二层，以此类推。
2. 称树中结点的最大层次数为树的深度或高度。
3. 若树中任意结点的子树均看成从左向右有次序的，不能随意交换，则称该树为有序树；否则称为无序树。
4. 由m（ m >= 0 ）棵互不相交的树构成的集合成为森林。
5. 双亲表示法：存储树的结点时，应该包含两个信息，一个是结点的值，另一个是结点的双亲关系。将所有的结点放在一个一维数组中即可。
6. 孩子表示法：存储树的结点时，包含两部分信息，一个是结点的值，另一个是该结点所有子女的位置。即：一个data域，存储该节点的数值，另一个为一个指针数组，用来存储指向该节点子女的指针。
7. 孩子兄弟表示法：存储树中每个节点的时候，除了包含该节点值域外，还设置两个指针firstchild和rightsibling，分别指向该结点的第一个孩子和右兄弟。即以二叉链表的方式进行存储。
8. 树的三种遍历
9. 树的线性表示：括号表示法、层号表示法。

## 基本概念

二叉树的定义为：二叉树是一个由节点构成的有限集合，这个集合或者为空，或者由一个根节点及两棵互不相交的分别称作这个根节点的左子树和右子树的二叉树组成。
这个定义是一个递归定义，当二叉树的节点集合为空时，称为空二叉树；否则，二叉树中至少包含一个根节点；如果根节点的左右子树非空，则其左右子树又分别是一棵二叉树。
一般树型结构中使用的术语如双亲（父母或前件）、子女（孩子或后件）、祖先、子孙、兄弟和路径等在二叉树中仍然可以沿用，但值得注意的是，二叉树并非一般的树型结构的特殊形式，他们为两种不同的数据结构。二叉树与一般树型结构的主要区别在于：第一、二叉树中每个非空节点最多只有两个子女，而一般的树形结构中每个非空节点可以有0到多个子女；第二、二叉树中节点的子树是要区分左右子树的，即使是在节点只有一棵子树的情况下也要明确指出是左子树还是右子树。

## 重要性质

二叉树具有以下重要性质：
1. 性质1：一棵非空二叉树的第i层上至多有2的i-1次方个结点(i>=1)。
2. 性质2：深度为h的二叉树至多有2的h次方-1个结点(其中h>=1)。（可以由性质1推出）
3. 性质3：对于任何一棵二叉树T，如果其终端结点数为n0，度为2的结点为n2，则n0 = n2 + 1。
在关于二叉树的许多实际应用中，经常用到两种特殊的二叉树：满二叉树和完全二叉树。
满二叉树一定为完全二叉树，但是完全二叉树不一定是满二叉树。
- 对于完全二叉树，具有以下性质：
性质4：对于具有n个结点的完全二叉树，如果按照从上到下、同一层次上的结点按从左到右的顺序对二叉树中的所有结点从1开始顺序编号，则对于序号为i的结点有：
（1）如果i > 1，则序号为i的结点其双亲结点的序号为不大于i/2的最大整数；如果i=1，则结点i为根结点，没有双亲。
（2）如果2i > n，则结点i无左子女（此时i结点为终端结点）；否则其左子女为结点2i。
（3）如果2i + 1 > n，则结点i无右子女，否则其右子女为结点2i + 1。

## 二叉树的存储结构

### 顺序存储结构

- 完全二叉树的顺序存储结构

```c
#define MAXSIZE 20
typedef char datatype;;
datatype tree[MAXSIZE];
int n;
```

通过此方式，可以利用子女和父母之间数组下标之间的关系来确定某节点的子女和父母的情况。

### 链式存储结构

二叉树链式存储方式下每个节点也包含三个域，一个数据域和两个指针域（指针域用来指向该节点的左右子树）。所以链式存储结构并不通过数组下标来确定该节点子女和父母的关系，而是通过指针的方式体现。

- 二叉树的链式存储方式

```c
typedef char datatype;
typedef struct node{
  datatype data;
  struct node * lchild, * rchild;
}bintnode;
typedef bintnode * bintree;
bintree root;
```

## 二叉树的遍历

### 二叉树遍历的递归实现

因为本身二叉树的定义形式就是以递归的形式给出的，所以其递归的遍历方式算法非常简便。

- 以前序遍历为例，其他两种递归遍历方式于此相似。

```c
void preorder(bintree t){
  if(t){
    printf("%c\n", t->data);
    preorder(t->lchild);
    preorder(t->rchild);
  }
}
```

### 二叉树遍历的非递归实现

二叉树的递归程序思路清晰，易于理解，但是执行效率低下。为了提高程序的执行效率，可以才用非递归的方式对二叉树进行遍历。

在才用非递归方式实现二叉树遍历的时候，必须使用一个栈用来记录回溯点埋一边将来进行回溯。

### 首先定义一个顺序栈，及其部分操作

```c
//对栈的基本存储结构进行定义
typedef struct stack{
  bintree data[100];
  int tag[100];
  int top;
}seqstack;
//进栈
void push(seqstack * s, bintree t){
  s->data[s->top] = t;
  s->top++;
}
//出栈
bintree pop(seqstack * s){
  if(s->top != 0){
    s->top--;
    return (s->data[s->top]);
  }
  else{
    return NULL;
  }
}
```

#### 二叉树的前序遍历的非递归实现

```c
void preorder1(bintree t){
  seqstack s;
  s.top = 0;
  while (t || s.top != 0) {
    if(t){
      printf("%c\n", t->data);
      push(&s, t);
      t = t->lchild;
    }
    else{
      t = pop(&s);
      t = t->rchild;
    }
  }
}
```

#### 二叉树的中序遍历的非递归实现

```c
void inorder1(bintree t){
  seqstack s;
  s.top = 0;
  while (t != NULL || s.top != 0) {
    if(t){
      push(&s, t);
      t = t->lchild;
    }
    else{
      t = pop(&s);
      printf("%c\n", t->data);
      t = t->rchild;
    }
  }
}
```

#### 二叉树的后序遍历的非递归实现

这！个！是！重！点！！！！！

```c
void postorder1(bintree t){
  seqstack s;
  s.top = 0;
  while (t || s.top != 0) {
    if(t){
      s.data[s.top] = t;
      s.tag[s.top] = 0;
      s.top++;
      t = t->lchild;
    }
    else{
      if(s.tag[s.top - 1] == 1){
        s.top --;
        t = s.data[s.top];
        printf("%c\n", t->data);
        t = NULL;
      }
      else{
        t = s.data[s.top - 1];
        s.tag[s.top - 1] = 1;
        t = t->rchild;
      }
    }
  }
}
```
